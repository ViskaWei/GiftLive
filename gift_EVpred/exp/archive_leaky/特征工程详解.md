# 🔧 特征工程详解

> **Date:** 2026-01-18  
> **Author:** Viska Wei  
> **Purpose:** 详细解释特征工程的具体实现和目的

---

## 📋 概述

**特征工程的目标**：将原始数据（click、gift、user、streamer、room）转换为模型可以学习的数值特征，用于预测"用户点击进入直播间后，在 15 分钟内是否会打赏，以及打赏多少"。

**特征工程分为三大部分**：
1. **静态特征**（Static Features）：用户/主播/房间的画像特征
2. **Past-only 聚合特征**（Frozen Features）：基于历史行为的统计特征
3. **时间上下文特征**（Time Context）：时间相关的特征

---

## 1. 静态特征（Static Features）

### 1.1 用户特征（User Features）

**来源**：`user.csv` 表

**特征列表**：
```python
user_features = [
    'age',                    # 年龄
    'gender',                 # 性别
    'device_brand',           # 设备品牌
    'device_price',           # 设备价格
    'fans_num',              # 粉丝数
    'follow_num',            # 关注数
    'accu_watch_live_cnt',   # 累计观看直播次数
    'accu_watch_live_duration', # 累计观看时长
    'is_live_streamer',      # 是否为主播
    'is_photo_author',        # 是否为照片作者
    'onehot_feat0' ~ 'onehot_feat6'  # 7 个 onehot 特征
]
```

**作用**：描述用户的基本画像和活跃度

**示例**：
- 高粉丝数 → 可能是 KOL，打赏能力可能更强
- 累计观看时长长 → 活跃用户，更可能打赏
- 设备价格高 → 消费能力可能更强

### 1.2 主播特征（Streamer Features）

**来源**：`streamer.csv` 表

**特征列表**：
```python
streamer_features = [
    'streamer_gender',        # 主播性别
    'streamer_age',           # 主播年龄
    'streamer_device_brand',   # 主播设备品牌
    'streamer_device_price',  # 主播设备价格
    'live_operation_tag',     # 直播运营标签
    'fans_user_num',          # 粉丝用户数
    'fans_group_fans_num',    # 粉丝群粉丝数
    'follow_user_num',        # 关注用户数
    'accu_live_cnt',          # 累计直播次数
    'accu_live_duration',     # 累计直播时长
    'accu_play_cnt',          # 累计播放次数
    'accu_play_duration',     # 累计播放时长
    'streamer_onehot_feat0' ~ 'streamer_onehot_feat6'  # 7 个 onehot 特征
]
```

**作用**：描述主播的影响力和受欢迎程度

**示例**：
- 粉丝数多 → 热门主播，可能吸引更多打赏
- 累计直播时长长 → 专业主播，内容质量可能更高

### 1.3 房间特征（Room Features）

**来源**：`room.csv` 表

**特征列表**：
```python
room_features = [
    'live_type',             # 直播类型
    'live_content_category'  # 直播内容类别
]
```

**作用**：描述直播内容的类型

**示例**：
- 游戏直播 vs 才艺直播 → 打赏模式可能不同

---

## 2. Past-only 聚合特征（Frozen Features）

### 2.1 核心思想

**问题**：如何利用历史打赏行为预测未来打赏？

**关键约束**：**只能用过去的信息，不能用未来的信息**（避免数据泄漏）

**Frozen 方法**：
1. 在 **训练集时间窗口内** 统计历史行为
2. 保存为 **Lookup 表**（字典）
3. 对 val/test 数据，直接查表（不更新）

### 2.2 Pair 特征（用户-主播交互）

**定义**：统计用户 (u) 对主播 (s) 的历史打赏行为

**特征计算**（在训练集窗口内）：
```python
# 1. 统计该 pair 的打赏次数
pair_gift_count = gift_train[
    (gift_train['user_id'] == u) & 
    (gift_train['streamer_id'] == s)
].shape[0]

# 2. 统计该 pair 的打赏总额
pair_gift_sum = gift_train[
    (gift_train['user_id'] == u) & 
    (gift_train['streamer_id'] == s)
]['gift_price'].sum()

# 3. 计算平均打赏金额
pair_gift_mean = pair_gift_sum / max(1, pair_gift_count)

# 4. 最后一次打赏时间
pair_last_gift_ts = gift_train[
    (gift_train['user_id'] == u) & 
    (gift_train['streamer_id'] == s)
]['timestamp'].max()

# 5. 距离最后一次打赏的时间间隔（小时）
pair_last_gift_time_gap = (current_click_ts - pair_last_gift_ts) / (1000 * 3600)
```

**最终特征**：
- `pair_gift_count_past`：历史打赏次数
- `pair_gift_sum_past`：历史打赏总额
- `pair_gift_mean_past`：历史平均打赏金额
- `pair_last_gift_time_gap_past`：距离最后一次打赏的时间间隔（小时）

**业务含义**：
- `pair_gift_sum_past` 高 → 该用户对该主播有打赏习惯，未来可能继续打赏
- `pair_last_gift_time_gap_past` 小 → 最近刚打过赏，可能再次打赏

**示例**：
```
用户 A 对主播 B：
- pair_gift_count_past = 10（打过 10 次）
- pair_gift_sum_past = 500（总共打赏 500 元）
- pair_gift_mean_past = 50（平均每次 50 元）
- pair_last_gift_time_gap_past = 2（2 小时前刚打过赏）

→ 模型会认为：用户 A 对主播 B 有很强的打赏倾向
```

### 2.3 User 特征（用户侧统计）

**定义**：统计用户 (u) 在训练窗口内的总打赏金额

**特征计算**：
```python
# 用户在训练窗口内的总打赏金额（7 天窗口）
user_total_gift_7d = gift_train[
    gift_train['user_id'] == u
]['gift_price'].sum()

# 用户预算代理（目前等于 7 天总额）
user_budget_proxy = user_total_gift_7d
```

**最终特征**：
- `user_total_gift_7d_past`：用户在训练窗口内的总打赏金额
- `user_budget_proxy_past`：用户预算代理（目前等于总打赏金额）

**业务含义**：
- `user_total_gift_7d_past` 高 → 用户是"金主"，打赏能力强
- 可用于识别 Top 1% 用户（打赏金额最高的用户）

**示例**：
```
用户 A：
- user_total_gift_7d_past = 5000（7 天内打赏了 5000 元）

→ 模型会认为：用户 A 是"金主"，打赏能力强
```

### 2.4 Streamer 特征（主播侧统计）

**定义**：统计主播 (s) 在训练窗口内的收入情况

**特征计算**：
```python
# 主播在训练窗口内的总收入
streamer_recent_revenue = gift_train[
    gift_train['streamer_id'] == s
]['gift_price'].sum()

# 主播在训练窗口内的打赏次数
streamer_gift_count = gift_train[
    gift_train['streamer_id'] == s
].shape[0]

# 主播在训练窗口内的唯一打赏用户数
streamer_recent_unique_givers = gift_train[
    gift_train['streamer_id'] == s
]['user_id'].nunique()
```

**最终特征**：
- `streamer_recent_revenue_past`：主播在训练窗口内的总收入
- `streamer_recent_unique_givers_past`：主播在训练窗口内的唯一打赏用户数

**业务含义**：
- `streamer_recent_revenue_past` 高 → 热门主播，可能吸引更多打赏
- `streamer_recent_unique_givers_past` 高 → 主播受欢迎，打赏用户多

**示例**：
```
主播 B：
- streamer_recent_revenue_past = 10000（7 天内收入 10000 元）
- streamer_recent_unique_givers_past = 100（有 100 个不同的用户打赏）

→ 模型会认为：主播 B 是热门主播，打赏氛围好
```

---

## 3. 时间上下文特征（Time Context）

**来源**：从 `click` 的 `timestamp` 提取

**特征计算**：
```python
# 将 timestamp（毫秒）转换为 datetime
click_base['timestamp_dt'] = pd.to_datetime(click_base['timestamp'], unit='ms')

# 提取时间特征
click_base['hour'] = click_base['timestamp_dt'].dt.hour          # 0-23
click_base['day_of_week'] = click_base['timestamp_dt'].dt.dayofweek  # 0-6
click_base['is_weekend'] = (click_base['day_of_week'] >= 5).astype(int)  # 0/1
```

**最终特征**：
- `hour`：小时（0-23）
- `day_of_week`：星期几（0-6）
- `is_weekend`：是否周末（0/1）

**业务含义**：
- 晚上 8-10 点 → 黄金时段，打赏可能更多
- 周末 → 用户时间充裕，打赏可能更多

---

## 4. 特征工程流程

### 4.1 完整流程

```python
# Step 1: 准备 click-level 数据
click_base = prepare_click_level_data(gift, click, label_window_hours=0.25)
# → 每条 click 对应一个 label：15 分钟内的打赏总额（0 或正数）

# Step 2: 创建静态特征
user_features, streamer_features, room_info = create_static_features(user, streamer, room)

# Step 3: Merge 静态特征到 click_base
df = click_base.merge(user_features, on='user_id', how='left')
df = df.merge(streamer_features, on='streamer_id', how='left')
df = df.merge(room_info, on='live_id', how='left')

# Step 4: 创建 Frozen Lookup 表（只用训练集）
lookups = create_frozen_features(gift, click, train_df)
# → 返回：{'pair': {...}, 'user': {...}, 'streamer': {...}}

# Step 5: 应用 Frozen 特征（优化版）
df = apply_frozen_features_optimized(df, lookups)
# → 使用 merge() 代替 iterrows()，107x 更快

# Step 6: 处理缺失值和类别编码
df[numeric_cols] = df[numeric_cols].fillna(0)
df[cat_cols] = df[cat_cols].astype('category').cat.codes

# Step 7: 创建目标变量
df['target'] = np.log1p(df['gift_price_label'])  # log(1+Y)
df['target_raw'] = df['gift_price_label']         # 原始金额
df['is_gift'] = (df['gift_price_label'] > 0).astype(int)  # 是否打赏
```

### 4.2 特征数量统计

**最终特征数量**：49 个

| 类别 | 数量 | 说明 |
|------|------|------|
| **静态特征** | ~30 | User + Streamer + Room |
| **Past-only 特征** | ~8 | Pair (4) + User (2) + Streamer (2) |
| **时间特征** | ~3 | Hour + DayOfWeek + IsWeekend |
| **其他** | ~8 | 编码后的类别特征 |

---

## 5. 为什么用 Frozen 方法？

### 5.1 避免数据泄漏

**错误做法**（会导致泄漏）：
```python
# ❌ 错误：用全量数据统计
pair_gift_sum = gift.groupby(['user_id', 'streamer_id'])['gift_price'].sum()
# → 这会把 test 数据也统计进去了！

# ✅ 正确：只用训练集统计
pair_gift_sum_train = gift_train.groupby(['user_id', 'streamer_id'])['gift_price'].sum()
# → 保存为 lookup，val/test 只查表
```

### 5.2 可复现性

**Frozen 方法**：
- 训练集统计结果固定
- val/test 查表结果固定
- 结果可复现

**Rolling 方法**（当前未使用）：
- 需要按时间排序，逐样本计算
- 实现复杂，容易出错
- 当前实现有泄漏问题，已废弃

### 5.3 性能优化

**优化前**（原始版本）：
```python
for idx, row in df.iterrows():  # 慢！
    key = (row['user_id'], row['streamer_id'])
    if key in lookups['pair']:
        df.at[idx, 'pair_gift_sum_past'] = lookups['pair'][key]['pair_gift_sum']
```
- 490 万条记录需要数小时

**优化后**（优化版本）：
```python
# 使用 merge() 代替 iterrows()
pair_df = pd.DataFrame(pair_data)
df = df.merge(pair_df, on=['user_id', 'streamer_id'], how='left')
```
- 490 万条记录仅需 3.5 分钟（107x 提升）

---

## 6. 特征重要性示例

**典型的重要特征**（从历史实验）：
1. `pair_gift_sum_past`：用户-主播历史打赏总额（最重要）
2. `pair_gift_mean_past`：用户-主播历史平均打赏金额
3. `user_total_gift_7d_past`：用户总打赏金额
4. `pair_last_gift_time_gap_past`：距离最后一次打赏的时间间隔

**特征重要性比**（最高/第二）：
- 泄漏版本：3x+（单一特征主导）
- Frozen 版本：1.23（特征重要性分布正常）

---

## 7. 总结

**特征工程的核心**：
1. **静态特征**：描述用户/主播/房间的基本画像
2. **Past-only 特征**：基于历史行为的统计（Frozen 方法，避免泄漏）
3. **时间特征**：捕捉时间模式

**关键原则**：
- ✅ **Past-only**：只能用过去的信息
- ✅ **Frozen 方法**：训练集统计，val/test 查表
- ✅ **优化版本**：使用 merge() 代替 iterrows()

**最终输出**：
- 49 个特征
- 每条 click 对应一个特征向量
- 用于预测：用户点击后 15 分钟内的打赏金额

---

> **最后更新**: 2026-01-18  
> **状态**: ✅ 当前实现
